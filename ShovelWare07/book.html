<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="William E. Byrd" />
  <meta name="dcterms.date" content="2026-02-07" />
  <title>Relational Interpreters in miniKanren (Fascicles I&amp;II)</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Relational Interpreters in miniKanren
(Fascicles I&amp;II)</h1>
<p class="author">William E. Byrd</p>
<p class="date">February 7, 2026</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#preface" id="toc-preface">Preface</a>
<ul>
<li><a href="#intended-audience-and-background-knowledge"
id="toc-intended-audience-and-background-knowledge">Intended audience
and background knowledge</a></li>
<li><a href="#goals-of-this-book" id="toc-goals-of-this-book">Goals of
this book</a></li>
<li><a href="#how-this-book-is-being-written"
id="toc-how-this-book-is-being-written">How this book is being
written</a></li>
<li><a href="#acknowledgments"
id="toc-acknowledgments">Acknowledgments</a></li>
</ul></li>
<li><a href="#rough-high-level-outline-subject-to-change"
id="toc-rough-high-level-outline-subject-to-change">(Rough high-level
outline, subject to change)</a></li>
<li><a
href="#brief-refresher-of-core-minikanren-and-relational-programming"
id="toc-brief-refresher-of-core-minikanren-and-relational-programming">Brief
refresher of core miniKanren and relational programming</a></li>
<li><a href="#techniques-for-debugging-minikanren-relations"
id="toc-techniques-for-debugging-minikanren-relations">Techniques for
debugging miniKanren relations</a></li>
<li><a href="#alternative-run-interfaces-for-minikanren"
id="toc-alternative-run-interfaces-for-minikanren">Alternative
<code>run</code> interfaces for miniKanren</a></li>
<li><a
href="#refresher-of-a-simple-environment-passing-scheme-interpreter-written-in-scheme"
id="toc-refresher-of-a-simple-environment-passing-scheme-interpreter-written-in-scheme">Refresher
of a simple environment-passing Scheme interpreter, written in
Scheme</a></li>
<li><a href="#techniques-for-debugging-interpreters-in-scheme"
id="toc-techniques-for-debugging-interpreters-in-scheme">Techniques for
debugging interpreters in Scheme</a></li>
<li><a
href="#simple-relational-environment-passing-scheme-interpreter-using-a-fully-tagged-representation-of-scheme-expressions-and-values"
id="toc-simple-relational-environment-passing-scheme-interpreter-using-a-fully-tagged-representation-of-scheme-expressions-and-values">Simple
relational environment-passing Scheme interpreter using a fully tagged
representation of Scheme expressions and values</a></li>
<li><a
href="#untagged-relational-scheme-interpreter-that-can-generate-quines"
id="toc-untagged-relational-scheme-interpreter-that-can-generate-quines">Untagged
relational Scheme interpreter that can generate Quines</a></li>
<li><a href="#techniques-for-debugging-interpreters-in-minikanren"
id="toc-techniques-for-debugging-interpreters-in-minikanren">Techniques
for debugging interpreters in miniKanren</a></li>
<li><a href="#tradeoffs-of-tagged-versus-untagged-representations"
id="toc-tradeoffs-of-tagged-versus-untagged-representations">Tradeoffs
of tagged versus untagged representations</a></li>
<li><a
href="#what-it-means-to-be-relational-and-the-role-of-constraints"
id="toc-what-it-means-to-be-relational-and-the-role-of-constraints">What
it means to be relational, and the role of constraints</a></li>
<li><a
href="#naive-representation-of-lambda-terms-using-logic-variables-for-alpha-equivalence"
id="toc-naive-representation-of-lambda-terms-using-logic-variables-for-alpha-equivalence">Naive
representation of <span class="math inline"><em>λ</em></span> terms
using logic variables for <span
class="math inline"><em>α</em></span>-equivalence</a></li>
<li><a href="#alternative-environment-representations"
id="toc-alternative-environment-representations">Alternative environment
representations</a></li>
<li><a href="#handling-mutation-using-store-passing-style"
id="toc-handling-mutation-using-store-passing-style">Handling mutation
using store-passing style</a></li>
<li><a href="#explicit-handling-of-errors"
id="toc-explicit-handling-of-errors">Explicit handling of
errors</a></li>
<li><a href="#adding-enough-to-handle-append"
id="toc-adding-enough-to-handle-append">Adding enough to handle
<code>append</code></a></li>
<li><a
href="#comparison-between-append-in-scheme-appendo-in-minikanren-and-append-in-the-relational-scheme-interpreter-running-inside-minikanren"
id="toc-comparison-between-append-in-scheme-appendo-in-minikanren-and-append-in-the-relational-scheme-interpreter-running-inside-minikanren">Comparison
between <code>append</code> in Scheme, <code>appendo</code> in
miniKanren, and <code>append</code> in the relational Scheme interpreter
running inside miniKanren</a></li>
<li><a
href="#synthesis-of-a-term-showing-difference-between-lexical-scope-and-dynamic-scope"
id="toc-synthesis-of-a-term-showing-difference-between-lexical-scope-and-dynamic-scope">Synthesis
of a term showing difference between lexical scope and dynamic
scope</a></li>
<li><a href="#scheme-anti-interpreter"
id="toc-scheme-anti-interpreter">Scheme “anti”-interpreter</a></li>
<li><a href="#handling-call-by-name-and-call-by-need"
id="toc-handling-call-by-name-and-call-by-need">Handling call-by-name
and call-by-need</a></li>
<li><a href="#handling-scheme-memoized-functions"
id="toc-handling-scheme-memoized-functions">Handling Scheme memoized
functions</a></li>
<li><a href="#writing-a-relational-abstract-interpreter"
id="toc-writing-a-relational-abstract-interpreter">Writing a relational
abstract interpreter</a></li>
<li><a href="#delayed-goals" id="toc-delayed-goals">Delayed
goals</a></li>
<li><a href="#speeding-up-the-interpreter"
id="toc-speeding-up-the-interpreter">Speeding up the
interpreter</a></li>
<li><a href="#synthesizing-append-using-associativity"
id="toc-synthesizing-append-using-associativity">Synthesizing
<code>append</code> using associativity</a></li>
<li><a
href="#exploring-sophisticated-behavior-under-relational-interpretation-proof-checker-and-quasiquote-quine-generation"
id="toc-exploring-sophisticated-behavior-under-relational-interpretation-proof-checker-and-quasiquote-quine-generation">Exploring
sophisticated behavior under relational interpretation: proof checker
and quasiquote Quine generation</a></li>
<li><a href="#build-your-own-barliman"
id="toc-build-your-own-barliman">Build Your Own Barliman</a></li>
<li><a href="#wanted-a-relational-hygienic-macro-expander"
id="toc-wanted-a-relational-hygienic-macro-expander">Wanted: a
relational hygienic macro expander</a></li>
<li><a href="#relational-compiler-as-opposed-to-interpreter"
id="toc-relational-compiler-as-opposed-to-interpreter">Relational
compiler, as opposed to interpreter</a></li>
<li><a href="#staging-interpreters-using-staged-minikanren"
id="toc-staging-interpreters-using-staged-minikanren">Staging
interpreters using staged-miniKanren</a></li>
<li><a href="#free-and-bound-variables-using-setkanrenclpset"
id="toc-free-and-bound-variables-using-setkanrenclpset">Free and bound
variables using setKanren/CLP(Set)</a></li>
<li><a href="#adding-arithmetic-to-a-relational-scheme-interpreter"
id="toc-adding-arithmetic-to-a-relational-scheme-interpreter">Adding
arithmetic to a relational Scheme interpreter</a></li>
<li><a
href="#a-small-step-lambda-calculus-reducer-and-capture-avoiding-substitution"
id="toc-a-small-step-lambda-calculus-reducer-and-capture-avoiding-substitution">A
small-step <span class="math inline"><em>λ</em></span>-calculus reducer
and capture-avoiding substitution</a></li>
<li><a
href="#a-small-step-lambda-calculus-reducer-using-de-bruijn-notation"
id="toc-a-small-step-lambda-calculus-reducer-using-de-bruijn-notation">A
small-step <span class="math inline"><em>λ</em></span>-calculus reducer,
using De Bruijn notation</a></li>
<li><a href="#a-small-step-term-reducer-for-the-ski-combinator-calculus"
id="toc-a-small-step-term-reducer-for-the-ski-combinator-calculus">A
small-step term reducer for the SKI combinator calculus</a></li>
<li><a href="#normalization-by-evaluation-relational-style"
id="toc-normalization-by-evaluation-relational-style">Normalization-by-evaluation,
relational style</a></li>
<li><a
href="#microkanren-in-the-barliman-style-relational-scheme-interpreter"
id="toc-microkanren-in-the-barliman-style-relational-scheme-interpreter">microKanren
in the Barliman-style relational Scheme interpreter</a></li>
<li><a
href="#shallow-medium-and-deep-embeddings-of-minikanren-in-minikanren"
id="toc-shallow-medium-and-deep-embeddings-of-minikanren-in-minikanren">Shallow,
medium, and deep embeddings of miniKanren-in-miniKanren</a></li>
<li><a
href="#relational-behavior-of-extra-logical-operators-in-a-deep-embedding-of-minikanren-in-minikanren"
id="toc-relational-behavior-of-extra-logical-operators-in-a-deep-embedding-of-minikanren-in-minikanren">Relational
behavior of extra-logical operators in a deep embedding of miniKanren in
miniKanren</a></li>
</ul>
</nav>
<p>An Unreasonable Schemer Production</p>
<p>This combination of Fascicles I&amp;II is Book 07 of Will’s
ShovelWare Book Pack</p>
<p>Edition 1 (Version 1.0) Sunday, February 7, 2026</p>
<p>Copyright 2026 William E. Byrd</p>
<p>This work is licensed under a Creative Commons Attribution 4.0
International License. (CC BY 4.0) <a
href="https://creativecommons.org/licenses/by/4.0/"
class="uri">https://creativecommons.org/licenses/by/4.0/</a></p>
<p><em>For Dan.</em></p>
<p>About Will’s ShovelWare Book Pack</p>
<p>In an experiment to see if I can train myself to finish writing a
book on my own—instead of just poking at it for a few weeks before
abandoning it and starting another—I have publicly committed to writing
and releasing seventeen (17) books in one year, releasing one book every
three weeks. I made the original announcement on Will Radio Part XXVIII
(<a href="https://www.youtube.com/watch?v=d6_cB-jtxYI"
class="uri">https://www.youtube.com/watch?v=d6_cB-jtxYI</a>) on
September 15, 2025, with the experiment to end on September 6, 2026,
when the 17th book is due.</p>
<p>Good or bad, short or long, my goal is to finish and release a book
every 21 days, like clockwork.</p>
<p>The idea for this experiment came from my kiloTube Video challenge
from a couple years ago. I had been wanting to make more videos, but was
suffering from perfectionism—I would record 70 or 80 takes of a video
before deleting it in disgust. So I publicly announced that I was going
to make 1,024 (or 2<sup>10</sup>) videos in a single year (one kiloTube
worth), in an attempt to force myself to just make video after video,
with the idea that I’d eventually learn the mechanics, and learn my own
style for making videos. Although I didn’t come close to making 1,024
videos that year (partly because making videos involved making noise,
which caused some social issues), the practice of making an average of 3
videos a day for weeks quickly got me over my perfectionism block. I now
have no trouble sitting down and making a video in one take, editing it,
and uploading it in a single sitting.</p>
<p>My hope is that after finishing and releasing a dozen or so books,
I’ll start to relax out a little, and will be over the fear of releasing
something less than perfect. There’s a go adage, “Lose your first
hundred games as quickly as possible.” I’m trying to write and release
my first dozen (or so) terrible books as quickly as possible. With 17
books to write, I might write a few decent ones, as well.</p>
<p>I am allowing myself to update books I’ve already released, so long
as I continue releasing a new book every 3 weeks.</p>
<p>This is the seventh of the 17 books, due on Sunday, February 8, 2026,
Anywhere on Earth (or whenever I go to sleep!). However, I’m releasing
this book on Saturday, February 7, since I’ll be traveling the next
week. (Originally I was going to release the books on Monday nights, but
Sundays work better.) The next book, book 08, will be due Sunday, March
1, 2026.</p>
<h2 id="preface">Preface</h2>
<p>This book explores an unusual approach to writing interpreters. An
<em>interpreter</em> is a computer program that can evaluate an
expression, producing a value. This is a very general idea, and an
amazing variety of computer programs can be considered interpreters of
some form. The most expressive and powerful class of interpreters can
evaluate expressions that represent arbitrary computer programs; such
interpreters can even evaluate themselves! Because interpreters appear
in so many areas of computation and computer science and programming,
they are well worth studying and exploring, from both typical and
unusual perspectives.</p>
<p>The unusual point of view taken in this book is that interpreters
should be viewed as—and implemented as—<em>relations</em> rather than as
<em>functions</em>. The typical perspective is that an interpreter is a
function (or machine) that takes as an <em>input</em> an expression
<em>e</em> (in some language) and produces as an <em>output</em> some
value <em>v</em>. The notions of input and output are central to this
view of an interpreter. The view taken in this book is that the
distinction between input and output is unnecessary and overly
restrictive. Instead, we view an interpreter as <em>relating</em> one or
more expressions with one or more values.</p>
<p>For the most part we will write interpreters that interpret
expressions in simple variants of the Scheme programming language. The
interpreters themselves, however, will generally be written in
miniKanren, a programming language designing for writing programs as
relations. We will use the faster-miniKanren implementation of
miniKanren, which is itself written in Scheme. Sometimes we’ll do
something trickier, such as writing a Scheme interpreter that is
interpreted by a different Scheme interpreter that is written in the
faster-miniKanren implement of miniKanren that is running in Scheme!
This can get confusing, so we’ll build up in complexity a little at a
time, and draw diagrams and give examples and exercises to help keep
everything straight.</p>
<p>The faster-miniKanren implementation of miniKanren we’ll be using
runs well in both Chez Scheme and in Racket. The book begins with a
brief introduction to the faster-miniKanren version of the miniKanren
programming language, and instructions on how to run faster-miniKanren
in Chez Scheme and in Racket.</p>
<h3 id="intended-audience-and-background-knowledge">Intended audience
and background knowledge</h3>
<p>This book is intended for anyone interested in exploring a
<em>relational programming</em> view of interpreters and
interpretation.</p>
<p>However, this is <em>not</em> a beginning programming book, nor is it
a self-contained course in miniKanren, relational programming, Scheme,
or interpreters. This book assumes that the reader has basic knowledge
of the Scheme programming language, basic functional programming
(including pattern matching), and basic knowledge of how to write an
interpreter for Scheme, in Scheme. The book also assumes the reader
understands basic relational programming in miniKanren—for example, as
provided by the second edition of Friedman, Byrd, Kiselyov, and Hemann’s
<em>The Reasoned Schemer</em> (MIT Press, 2018), or from the various
miniKanren tutorials and videos available online or in academic
papers.</p>
<p>As much as I’d like to include all of the required background
information in a single book (and I <em>have</em> tried, several times),
to adequately cover this material would require presenting the
equivalent of an entire series of university courses. It is my dream to
eventually write such a series, but I think it makes sense to start with
the most unique material first, and then work backwards.</p>
<p>Fortunately, there are many fine books, tutorials, videos, and
courses that teach the Scheme programming language, functional
programming, pattern matching, program transformations, and
interpreters. A few well-known books include: <em>Structure and
Interpretation of Computer Programs, 2nd edition</em> by Harold Abelson
and Gerald Jay Sussman, with Julie Sussman (MIT Press, 1996); <em>The
Scheme Programming Language, 4th edition</em> by R. Kent Dybvig (MIT
Press, 2009); <em>Essentials of Programming Languages, 3rd edition</em>
by Daniel P. Friedman and Mitchell Wand (MIT Press, 2008); <em>The
Little Schemer, 4th edition</em> by Daniel P. Friedman and Matthias
Felleisen (MIT Press, 1995); <em>Lisp in Small Pieces</em> by Christian
Queinnec (Cambridge University Press, 2003); and <em>Types and
Programming Languages</em> by Benjamin C. Pierce (MIT Press, 2002)</p>
<p>Pointers to miniKanren-related resources can be found at <a
href="https://minikanren.org/" class="uri">https://minikanren.org/</a>.
The standard introductory book on miniKanren is <em>The Reasoned
Schemer, 2nd edition</em> by Daniel P. Friedman, William E. Byrd, Oleg
Kiselyov, and Jason Hemann (MIT Press, 2018). (Full disclosure: I’m one
of the authors of both editions of <em>The Reasoned Schemer</em>!)</p>
<h3 id="goals-of-this-book">Goals of this book</h3>
<p>In addition to showing the basics of how to write interpreters as
relations, a goal of this book is to show a <em>way of thinking</em>
about writing non-trivial relational programs in miniKanren. In other
words, to reify the implicit knowledge shared by miniKanren hackers that
hasn’t been written down, or is spread out among talks, papers, and
dissertations. What does an experienced miniKanren hacker/researcher
think about when writing or improving a relational program? What are the
key ideas, techniques, traps, and pitfalls? What are alternative
approaches to standard problems, and what are their tradeoffs? How do we
think about relationality? How do we decide when a new constraint is
warranted? Which problems do we seem to have some handle on, and which
do we try to avoid or consider core research problems? Why do we use a
more sophisticated approach or encoding when a simpler, more direct
approach seems like it might work? (To give a specific example, why do
we tend to write big-step interpreters rather than small-step term
reducers, and is that preference due to an essential difference, or just
to the lack of our understanding and technique?)</p>
<p>I will have succeeded, at least in part, if readers of this book come
away with the ability to critique and improve relational programs,
especially relational interpreters. I hope readers also will understand
the motivation behind topics that interest miniKanren researchers that
might otherwise appear esoteric, such as nominal logic programming,
higher-order logic programming, and the Extended Andorra model. Readers
should be able to pick up miniKanren-related research papers and get a
sense of how those works fits into the bigger picture of relational
programming, especially with respect to relational interpretation.</p>
<h3 id="how-this-book-is-being-written">How this book is being
written</h3>
<p>This is a book “in progress” on writing interpreters are relations in
miniKanren. The idea is to release one fascicle, or “bundle,” every
three weeks for the remainder of the ShovelWare Book Pack experiment.
The first fascicle included the draft of this preface. I plan to release
one fascicle (which may or may not correspond to a chapter) every three
weeks. I should end up with 12 fascicles worth of work on this book by
September 15, 2025, when the 17th ShovelWare book is due. I can then
either revise the book, continue extending it, move onto another book,
or take a break.</p>
<p>Originally I had planned on releasing the book in old-school serial
fashion by concatenating the fascicles as I write them, releasing the
latest version of the book’s “prefix.” After a few days of work on the
second fascicle, though, I think I’ll try doing passes over the entire
book, refining and expanding every chapter with each complete pass in
stages: rough notes for each chapter, refined into an outline for each
chapter, refined into a complete draft down to the paragraph level for
each chapter, refined into a complete draft down to the sentence level
for each chapter, refined into completed chapters. (I did something
similar with my PhD dissertation.) One way to think about how I’m
writing this book is as notes for teaching a course, being refined over
many passes.</p>
<h3 id="acknowledgments">Acknowledgments</h3>
<p>Marco Marchesin suggested releasing fascicles of a larger book
instead of writing one self-contained tiny book each week as part of my
ShovelWare Book Pack experiment, which I’m attempting with this book.
Thank you, Marco!</p>
<p>The first five ShovelWare books I’ve released, as bad and incomplete
as they may be, helped me get in the position mentally to try this
approach. So, thank you to those books, and to anyone who subjected
themselves to reading them.</p>
<p>A proper acknowledgment of all the work on miniKanren and relational
interpreters would fill many pages. As always, there is the danger of
leaving people out, or mixing up contributions from years ago. I will
write a proper acknowledgments section, although I know from experience
it may take multiple fascicles before I dare show the acknowledgments
publicly. For now, let me thank everyone in the miniKanren community,
especially my teachers, mentors, collaborators, and students.</p>
<p>Will Byrd</p>
<p>Mt. Pleasant, South Carolina</p>
<p>February, 2026</p>
<h2 id="rough-high-level-outline-subject-to-change">(Rough high-level
outline, subject to change)</h2>
<p>Here is the current high-level outline for this book, subject to
reordering, addition, and deletion:</p>
<ol>
<li><p>Brief refresher of core miniKanren and relational programming,
brief description of the faster-miniKanren implementation and the
language it supports (including constraints other than <code>==</code>),
and a few examples of relations using this language (with pointers to
resources that cover these topics);</p></li>
<li><p>techniques for debugging miniKanren relations;</p></li>
<li><p>design and write Scheme macros that provide alternative
interfaces to <code>run n</code> and <code>run*</code> that return
<em>sets</em> rather than <em>lists</em>, and for which the
<code>run*</code> equivalent uses depth-first search rather than
interleaving search, along with justification for why this is worth
experimenting with;</p></li>
<li><p>refresher of a simple environment-passing Scheme interpreter,
written in Scheme, using a first-order representation of procedures and
environments, written using pattern matching and quasiquotation, and
supporting lexical scope and shadowing (with pointers to resources that
cover these topics);</p></li>
<li><p>techniques for debugging interpreters in Scheme;</p></li>
<li><p>introduce simple tagged representation of expressions and values,
and simple association list representation of environments, working up
to a simple relational environment-passing Scheme interpreter using a
fully tagged representation of Scheme expressions and values;</p></li>
<li><p>use constraint extensions to core miniKanren, along with the
<code>not-in-envo</code> helper relation, to untag the representations
of Scheme variables, numbers, procedure application, and add
<code>quote</code> to the interpreter (with the help of
<code>absento</code> to prevent quoted closures as expressions), working
up to an untagged relational Scheme interpreter that can synthesize
values such as <code>(I love you)</code>, along with Quines, twines, and
thrines (using nother <code>absento</code> trick to generate more
interesting twines and thrines);</p></li>
<li><p>techniques for debugging interpreters in miniKanren;</p></li>
<li><p>(as an aside from improving the relational Scheme interpreter)
explore tradeoffs of tagged versus untagged representations, including
the issues of writing parsers/unparsers for tagged terms containing
fresh variables in tag position, and investigate a fully-tagged version
of the Quine-generating relational interpreter that uses <code>==</code>
as the only constraint, first explored by Nada Amin;</p></li>
<li><p>(as an aside from improving the relational Scheme interpreter)
explore what it means to be relational, the role of constraints in
expressing limited forms of negation and avoiding branching, unbounded
recursion/unbounded number of successes/enumerating infinite (or
gigantic) domains, discuss the role of constraints in the relational
interpreter, and discuss when and how to design and implement a new
constraint;</p></li>
<li><p>explore issues around the apparently attractive approach of using
logic variables and first-order syntactic unification to represent
lexical scoping, binding, and <span
class="math inline"><em>α</em></span>-equivalence with tagged lists
representing <span class="math inline"><em>λ</em></span> terms:</p>
<pre><code>(fresh (a b c d)
  (== `(lambda (,a) (lambda (,b) ,a))
      `(lambda (,c) (lambda (,d) ,d))))</code></pre>
<p>or:</p>
<pre><code>(fresh (a b c)
  (== `(lambda (,a) (lambda (,a) ,a))
      `(lambda (,b) (lambda (,c) ,b))))</code></pre>
<p>and the resulting motivation for nominal unification, or other
approaches;</p></li>
<li><p>explore alternative environment representations, including a
“split” two-list representation, and another representation using
association list constraints, working up to a relational interpreter
with <code>lookupo</code> and <code>not-in-envo</code> relations that
succeed finitely many times for environments that are not length
instantiated;</p></li>
<li><p>write relational interpreters that handle mutation using
store-passing style;</p></li>
<li><p>write interpreters with explicit handling of errors, showing how
angelic execution can be used to synthesize expressions that, when
evaluated, generate a given error;</p></li>
<li><p>add <code>letrec</code> and recursive environments, and add a
simple pattern matcher to the relational Scheme interpreter, taking
special care to explicitly handle the cases of not matching (which is
the trickier part!), working up to a relational Scheme interpreter that
can interpret <code>append</code>, can synthesize arguments to
<code>append</code> using idioms like
<code>(append '(a b c) ',x)</code>, and can synthesize small code
expressions inside the definition of <code>append</code>;</p></li>
<li><p>discuss the similarities and differences between
<code>append</code> in Scheme, <code>appendo</code> in miniKanren, and
<code>append</code> in the relational Scheme interpreter running inside
miniKanren;</p></li>
<li><p>explore a neat example from the 2017 ICFP pearl: synthesizing an
expression that evaluates to different values under lexical scope versus
dynamic scope through sharing a fresh variable in the expression
position for two relational interpreters, and using a disequality
constraint to enforce the the value arguments differ;</p></li>
<li><p>write a relational Scheme “anti”-interpreter,
<code>not-evalo</code>, where <code>(not-evalo expr val)</code> succeeds
when Scheme expression <code>expr</code> does <em>not</em> evaluate to
value <code>val</code>;</p></li>
<li><p>write relational Scheme interpreters that implement call-by-name
and call-by-need, rather than call-by-value;</p></li>
<li><p>write a relational Scheme interpreter that supports memoized
functions;</p></li>
<li><p>write a relational abstract interpreter;</p></li>
<li><p>add delayed goals to faster-miniKanren, and explore uses of—and
tradeoffs of—delayed goals in relational interpreters;</p></li>
<li><p>explore techniques for radically speeding up the interpreter in
certain cases, such as dynamic reordering of conjunctions of recursive
calls based on groundness of terms, and using a Scheme function rather
than a miniKanren relation for variable lookup in the interpreter’s
environment when the arguments are sufficiently ground, working up to a
relational Scheme interpreter that can synthesize <code>append</code>
from expression/value pairs;</p></li>
<li><p>explore synthesizing <code>append</code> and other recursive
definitions using properties such as <em>associativity</em>, rather than
only input/output pairs;</p></li>
<li><p>explore sophisticated example programs from the 2017 ICFP pearl:
proof checker becomes theorem prover via relational interpretation, and
quasiquote Quine generation using a micro-Scheme in mini-Scheme in
miniKanren in Scheme;</p></li>
<li><p>build a simple clone of Barliman, including Barliman’s technique
of trying to parse an expression relationally in the hope of failing
fast, and throwing away any information gained upon success to avoid
premature grounding before calling the evaluator, and also running each
input/output pair on its own, in parallel with the entire synthesis
problem (once again, hoping to fail fast);</p></li>
<li><p>(as an aside from implementing relational interpeters) discuss
lack of a relational hygienic macro expander, its implications, possible
work arounds, and open problems;</p></li>
<li><p>(as an aside from implementing relational interpeters) discuss
relational compiler, rather than interpreter, for Scheme, along with
tradeoffs, opportunities, and problems;</p></li>
<li><p>use the staged-miniKanren system to perform staged evaluation of
relational interpreters, giving cool examples from the PLDI paper and
repo;</p></li>
<li><p>consider the apparently simple notions of free and bound
variables from a relational context, implementing C311-style functions
relationally using setKanren/CLP(Set);</p></li>
<li><p>consider the apparently simple task of adding arithmetic to a
relational Scheme interpreter, and explore the various ways this may be
done, including using variable projection, delayed goals, tagged Peano
numerals, “Kiselyov” numerals, finite domain constraints, and
CLP(SMT);</p></li>
<li><p>write a small-step <span
class="math inline"><em>λ</em></span>-calculus reducer, based on
capture-avoiding substitution, exploring issues related to names and
binding;</p></li>
<li><p>write a small-step <span
class="math inline"><em>λ</em></span>-calculus reducer, using De Bruijn
notation, and explore issues and tradeoffs;</p></li>
<li><p>write a small-step term reducer for the SKI combinator calculus,
and explore the tradeoffs in terms of avoiding nominal issues with
capture-avoiding substitution and <span
class="math inline"><em>α</em></span>-equivalence, and the difficulties
related to failing fast, showing <span
class="math inline"><em>Ω</em></span> as a small-step Quine, working up
to synthesizing combinator terms and fixpoint combinators (Question: can
this reducer be staged by staged-miniKanren?);</p></li>
<li><p>explore the technique of normalization-by-evaluation (or
<em>NBE</em>) from a relational standpoint, resulting in two relations,
<code>evalo</code> and <code>unevalo</code>, that together can
synthesize a fixpoint function in Scheme (and explore technique for
ensuring freshness of lexical variables using <code>absento</code> and a
list of variables encountered so far (which do not have to be
ground));</p></li>
<li><p>run a slightly massaged version of the Scheme code for
microKanren in the Barliman-style relational Scheme interpreter, then
explore the behavior of microKanren programs in this relational context,
including the behavior of extra-logical operators such as
<code>varo</code>;</p></li>
<li><p>implement shallow, medium, and deep embeddings of
miniKanren-in-miniKanren, and run queries that share arguments between
shallower and deeper embeddings to expore tradeoffs between performance
versus expressive power;</p></li>
<li><p>explore the relational behavior of extra-logical operators in a
deep embedding of miniKanren in miniKanren, including aggregate
operators inspired by Prolog’s <code>findall</code> and
<code>setof</code> predicates, implemented using
setKanren/CLP(Set).</p></li>
</ol>
<p>Worth thinking about for each chapter:</p>
<ul>
<li>Concepts and themes</li>
<li>Techniques</li>
<li>Code</li>
<li>Examples</li>
<li>Exercises</li>
<li>Research problems</li>
</ul>
<h2
id="brief-refresher-of-core-minikanren-and-relational-programming">Brief
refresher of core miniKanren and relational programming</h2>
<p>Brief refresher of core miniKanren and relational programming, brief
description of the faster-miniKanren implementation and the language it
supports (including constraints other than <code>==</code>), and a few
examples of relations using this language (with pointers to resources
that cover these topics)</p>
<p>core miniKanren, in this order: <code>==</code>, <code>run*</code>,
<code>conde</code>, <code>fresh</code>, <code>run n</code></p>
<p><code>appendo</code></p>
<p>reordering of goals</p>
<p>faster-miniKanren—Chez Scheme and Racket (what about Schemes other
than Chez?)</p>
<p><code>=/=</code>, <code>symbolo</code>, <code>numbero</code>,
<code>stringo</code>, <code>absento</code></p>
<p>disjointness of type constraints</p>
<p>common confusion about what <code>=/=</code> means; common confusion
about <code>=/=</code> versus <code>absento</code></p>
<p><code>project</code>, <code>onceo</code>, <code>conda</code>,
<code>condu</code></p>
<p>difference in behavior between TRS1 and “modern” miniKanrens</p>
<p>what about “classic” miniKanren implementations, other than
faster-miniKanren? Also, staged-miniKanren, clpset-faster-miniKanren,
microKanren implementation (and variant in TRS2), TRS1 and TRS2
implementations (and pointers to code), etc.</p>
<h2 id="techniques-for-debugging-minikanren-relations">Techniques for
debugging miniKanren relations</h2>
<p>printing/tracing, both using <code>project</code> explicitly and by
writing a helper macro, using all fresh vars as arguments, using all
ground arguments, <code>run 1</code> when <code>run*</code> or
<code>run n</code> for <span class="math inline"><em>n</em></span> &gt;
1 is taking a long time, comment out recursive clauses and try with all
fresh vars, replace recursive calls with a succeeding goal</p>
<h2 id="alternative-run-interfaces-for-minikanren">Alternative
<code>run</code> interfaces for miniKanren</h2>
<p>design and write Scheme macros that provide alternative interfaces to
<code>run n</code> and <code>run*</code> that return <em>sets</em>
rather than <em>lists</em>, and for which the <code>run*</code>
equivalent uses depth-first search rather than interleaving search,
along with justification for why this is worth experimenting with</p>
<p>introduce new <code>run-set n</code> and <code>run-set*</code>
syntax, and keep existing <code>run n</code>/<code>run*</code>
syntax</p>
<p><code>run-set*</code> and DFS (which would be enabling for both more
efficient incremental CLP(SMT) calling, and easier
tracing/debugging)</p>
<p>sets in Chez and Racket</p>
<p>start with existing macros</p>
<p>macro part versus function part</p>
<p><code>take</code>, streams, and all of that</p>
<p>how sets differ from multisets</p>
<p><code>run-set n</code> runs until <span
class="math inline"><em>n</em></span> <em>distinct</em> answers are
produced: <code>(run-set 2 (q) (fives-forevero q))</code> would diverge
for this reason, while the <code>run 2</code> variant would return the
list <code>(5 5)</code>, which seems like a strong argument for
<code>run-set n</code> and <code>run-set*</code> to be distinct from
<code>run n</code> and <code>run*</code>, instead of replacing them</p>
<p>overlapping answers/subsumption, etc.</p>
<p>(connections with and differences from
clpset-faster-miniKanren/CLP(Set))</p>
<p>show how <code>run-set*</code> can be faster/use less memory than
<code>run-set 1</code>, <code>run*</code>, and <code>run 1</code>, due
to DFS versus interleaving search</p>
<p><code>run-set n</code> answers as a subset of <code>run-set*</code>
answers (if they both terminate)</p>
<p>if using CLP(SMT), the DFS nature of <code>run-set*</code> could
enable efficient incremental calling of the solver, possibly resulting
in better fail-fast behavior of <code>run-set*</code> than
<code>run-set n</code>, <code>run*</code>, or <code>run n</code>.</p>
<h2
id="refresher-of-a-simple-environment-passing-scheme-interpreter-written-in-scheme">Refresher
of a simple environment-passing Scheme interpreter, written in
Scheme</h2>
<p>refresher of a simple environment-passing Scheme interpreter, written
in Scheme, using a first-order representation of procedures and
environments, written using pattern matching and quasiquotation, and
supporting lexical scope and shadowing (with pointers to resources that
cover these topics)</p>
<p>variables, binding, environment, shadowing, lexical scope</p>
<p>representing a variable as a symbol, equality comparison for
comparing variable equality</p>
<p>shadowing via <code>cons</code>, look up, empty environment</p>
<p>higher-order versus association list versus tagged list
representation, and lookup</p>
<p>Pattern matching, <code>quasiquote</code>, <code>unquote</code>,
call-by-value <span class="math inline"><em>λ</em></span>-calculus core,
single-argument <span class="math inline"><em>λ</em></span> and
application</p>
<p>tagged/untagged procedure application</p>
<p>first-order/higher-order procedure and environment
representations</p>
<p>representation independence</p>
<h2 id="techniques-for-debugging-interpreters-in-scheme">Techniques for
debugging interpreters in Scheme</h2>

<h2
id="simple-relational-environment-passing-scheme-interpreter-using-a-fully-tagged-representation-of-scheme-expressions-and-values">Simple
relational environment-passing Scheme interpreter using a fully tagged
representation of Scheme expressions and values</h2>
<p>introduce simple tagged representation of expressions and values, and
simple association list representation of environments, working up to a
simple relational environment-passing Scheme interpreter using a fully
tagged representation of Scheme expressions and values</p>
<p>Tagged expressions, tagged application, tagged values, lookupo (and
its behavior), simple language, issues with fresh logic variables and
tag positions</p>
<p>write parser/unparser, and show issues with those programs when fresh
variables are involved</p>
<p>Shadowing and duplicate answers (shadowing built-in primitives like
<code>cons</code>)</p>
<p>show synthesis</p>
<p>Alas, can’t just go to or from Scheme (motivating parser and parser,
and eventually motivating desire for untagged representation).</p>
<p>Duplicate answers due to shadowing of primitives, leading to desire
for <code>not-in-envo</code>.</p>
<p>Call-by-value <span class="math inline"><em>λ</em></span>-calculus,
plus <code>cons</code> and <code>quote</code> (Maybe hold off on
<code>quote</code>, until tagging is removed in a subsequent
chapter.</p>
<p>issue with quoted closures.</p>
<p>(Do I want to break some of these issues down to be addressed in
different chapters?)</p>
<h2
id="untagged-relational-scheme-interpreter-that-can-generate-quines">Untagged
relational Scheme interpreter that can generate Quines</h2>
<p>use constraint extensions to core miniKanren, along with the
<code>not-in-envo</code> helper relation, to untag the representations
of Scheme variables, numbers, procedure application, and add
<code>quote</code> to the interpreter (with the help of
<code>absento</code> to prevent quoted closures as expressions), working
up to an untagged relational Scheme interpreter that can synthesize
values such as <code>(I love you)</code>, along with Quines, twines, and
thrines (using another <code>absento</code> trick to generate more
interesting twines and thrines)</p>
<p><code>(I love you)</code> synthesis</p>
<p>Shuould already have introduced <code>not-in-envo</code> to prevent
duplicate answers due to shadowing of primitives. Will also need it for
untagging procedure application</p>
<p>Untagged procedure application only leads to overlapping behavior if
the expression for application overlaps with that of the other
interpreter clauses (if there lengths overlap, basically)</p>
<p>So, <code>(lambda (,x) ,e)</code> doesn’t overlap with
<code>(,e1 ,e2)</code></p>
<p>of course, once we have multi-argument <span
class="math inline"><em>λ</em></span> and application, supporting with
any number of arguments, the application case will overlap with all of
the other cases that have non-empty list sytax (won’t overlapped with
<code>numbero</code> or <code>symbolo</code> or <code>stringo</code>
cases that use type constraints)</p>
<p>(where do we put multi-argument and variadic <span
class="math inline"><em>λ</em></span> and application?)</p>
<p><code>quote</code>, quoted closures, whack-a-mole once you have
<code>cons</code>, <code>car</code>, <code>cdr</code>.
<code>absento</code> on the <code>closure</code> tag. where to put
<code>absento</code> call? driver relations vs. ensuring helpers are
self contained</p>
<pre><code>(run 1 (q r)
  (=/= q r)
  (evalo q r)
  (evalo r q))</code></pre>
<p>Every Quine is a trivial twine. Need the disequality constraint for
non-triviality</p>
<p>(This chapter has a lot, maybe break it down)</p>
<h2 id="techniques-for-debugging-interpreters-in-minikanren">Techniques
for debugging interpreters in miniKanren</h2>

<h2 id="tradeoffs-of-tagged-versus-untagged-representations">Tradeoffs
of tagged versus untagged representations</h2>
<p>(as an aside from improving the relational Scheme interpreter)
explore tradeoffs of tagged versus untagged representations, including
the issues of writing parsers/unparsers for tagged terms containing
fresh variables in tag position, and investigate a fully-tagged version
of the Quine-generating relational interpreter that uses <code>==</code>
as the only constraint, first explored by Nada Amin</p>
<p>Revisit Quine generation using fully tagged representation, using
Nada Amin’s <code>==</code>-only approach. Issues with that approach,
possible fixes, and possible remaining issues.</p>
<p>(An example of critique of a relational interpreter, and of
relational programs in general.)</p>
<p>Formal verification or proof would be very useful in this area.</p>
<p>Can I recapitulate the confusion with fully tagged terms, including
tagged application and variables, in generated Quines, from
Clojure/conj? Back then, I was never quite sure which terms were legal,
what was a legal Quine, etc. Made me want to get rid of the tags and be
able to run synthesized code directly in Scheme, and to run Scheme code
directly in the relational intepreter. (An approach I think has served
us well.)</p>
<h2 id="what-it-means-to-be-relational-and-the-role-of-constraints">What
it means to be relational, and the role of constraints</h2>
<p>(as an aside from improving the relational Scheme interpreter)
explore what it means to be relational, the role of constraints in
expressing limited forms of negation and avoiding branching, unbounded
recursion/unbounded number of successes/enumerating infinite (or
gigantic) domains, discuss the role of constraints in the relational
interpreter, and discuss when and how to design and implement a new
constraint</p>
<p>Peano numerals: `<code>(S ,n)</code> is one greater than
<code>n</code>, and is therefore larger than <code>n</code>, and is also
therefore a <em>positive</em> integer. Even though we don’t know what
the value of <code>n</code> is, we can do at least some reasoning
<em>without</em> grounding or enumerating <code>n</code>. This abstract,
numeral represents infinitely many concrete, ground numerals:
<code>(s z)</code>, <code>(s (s z))</code>, <code>(s (s (s z)))</code>,
…</p>
<p><code>zeroo</code> and <code>poso</code>: give their definitions, and
show how `(s ,n) works with them.</p>
<p>Notions of relationality: reordering conjuncts and disjuncts,
swapping argumentsto <code>==</code> (and to <code>=/=</code>), the
ability to use ground, fresh, or partially ground terms for any
argument</p>
<p>show why <code>mapo</code> is not relational. Similarly for
<code>project</code>.</p>
<p>Limited notions of negation with constraints. Punching out one value
in an infinite domain, versus <code>booleano</code>, which brings you
into finite domain constraints.</p>
<p>The art, or trick, of effective relational programming is to come up
with data representations and use constraints (perhaps create new
constraints) to represent infinitely many possibilities (or gigantic but
finite numbers of possibilities), thereby avoiding enumerating all of
the possibilities one-by-one, which is hopeless.</p>
<pre><code>(fresh (n) (numbero n))</code></pre>
<p>or the tagged numeral</p>
<pre><code>(fresh (n) (num ,n)</code></pre>
<p>are both abstractions that avoid having to enumerate all of the
infully many numerals.</p>
<pre><code>(fresh (x)
  (symbolo x)
  (numbero x))</code></pre>
<p>fails finitely, as does</p>
<pre><code>(fresh (e x n)
  (== `(sym ,x) e)
  (== `(num ,n) e))</code></pre>
<p>without grounding <code>x</code>, or <code>n</code>, or fully
grounding <code>e</code>.</p>
<p>want to avoid generate and test at all costs.</p>
<h2
id="naive-representation-of-lambda-terms-using-logic-variables-for-alpha-equivalence">Naive
representation of <span class="math inline"><em>λ</em></span> terms
using logic variables for <span
class="math inline"><em>α</em></span>-equivalence</h2>
<p>explore issues around the apparently attractive approach of using
logic variables and first-order syntactic unification to represent
lexical scoping, binding, and <span
class="math inline"><em>α</em></span>-equivalence with tagged lists
representing <span class="math inline"><em>λ</em></span> terms:</p>
<pre><code>(fresh (a b c d)
  (== `(lambda (,a) (lambda (,b) ,a))
      `(lambda (,c) (lambda (,d) ,d))))</code></pre>
<p>or:</p>
<pre><code>(fresh (a b c)
  (== `(lambda (,a) (lambda (,a) ,a))
      `(lambda (,b) (lambda (,c) ,b))))</code></pre>
<p>and the resulting motivation for nominal unification, or other
approaches;</p>
<p>You sometimes see these sorts of encodings in Prolog, although I’ve
never seen the encoding use in a way that was actually fully relational.
You always seem to use need to use a <code>copy_term</code>.</p>
<p>Doesn’t work in terms of lexical scope, binding, shadowing, et
cetera.</p>
<p>Either avoid this type of encoding entirely, and use symbols to
represent variables, and either use an explicit environment or use De
Bruijn, or use combinatory logic and avoid variables entirely, or try to
implement capture-avoiding-substitution (CAS) relationally, or go higher
order and do higher order abstract syntax (HOAS). This stuff is subtle,
and an ongoing area of research in programming languages in general.</p>
<p>De Bruijn and implementing-capture-avoiding substitution relationally
are both trickier to implement purely relationally than it might appear
at first glance, at least if you’re using first-order syntactic
unification, which is the vanilla unification algorithm for
miniKanren.</p>
<p>miniKanren’s default unification has no build-in reasoning with
respect to scope or binding. <code>lambda</code> here is just an
arbitrary symbol, and <code>a</code>, <code>b</code>, and <code>c</code>
are just standard unification variables.</p>
<p>It’s an attractive notion to do application in <span
class="math inline"><em>λ</em></span>-calculus using unification of
<code>a</code>, <code>b</code>, or <code>c</code> to represent the
result of a procedure application. For example, reducing the term:</p>
<pre><code>`(app (lambda (,a) (lambda (,b) ,a)) (lambda (,c) ,c))</code></pre>
<p>results in the unification:</p>
<pre><code>(== `(lambda (,c) ,c) a)</code></pre>
<p>The steps in schematic form:</p>
<pre><code>`(app ,e1 ,e2)
(== `(lambda (,a) (lambda (,b) ,a)) e1)
(== `(lambda (,c) ,c) e2)
(== a e2)</code></pre>
<p><code>a</code> becomes:</p>
<pre><code>`(lambda ((lambda (,c) ,c)) (lambda (,b) (lambda (,c) ,c)))</code></pre>
<p>If you just look at the body this term, it can appear okay. However,
the unification ruins <code>a</code> and ruins the original term
corresponding to <code>e1</code>, which means <code>copy_term</code> is
needed to copy the “template” of the original term <em>before</em>
unification, which isn’t relational (because reordering the conjuncts
changes the semantics of the program). (Note also that the constraint
<code>(symbolo a)</code> is no good, because <code>a</code> is going to
be unified with some representation of a <span
class="math inline"><em>λ</em></span>-calculus term, which is probably a
tagged list.)</p>
<p>This motivates why you might want something like nominal logic
programming or to do something more like <span
class="math inline"><em>λ</em></span>Prolog and use a higher order
abstract syntax encoding. But those bring along their own
complications.</p>
<h2 id="alternative-environment-representations">Alternative environment
representations</h2>
<p>explore alternative environment representations, including a “split”
two-list representation, and another representation using association
list constraints, working up to a relational interpreter with
<code>lookupo</code> and <code>not-in-envo</code> relations that succeed
finitely many times for environments that are not length
instantiated</p>
<p>Check that I included notions of <code>free?</code> and
<code>bound?</code>, and showed how to implement using
clpset-faster-miniKanren/CLP(Set), like in the beginning of C311 and
TAPL.</p>
<p><code>not-in-envo</code> is especially pesky since it is used so
often. Show why recursive <code>lookupo</code> and
<code>not-in-envo</code> can cause divergence through succeeding an
unbounded number of times. Show various issues with association list
representation of environments, for <code>lookupo</code> and
<code>not-in-envo</code> with environment that aren’t ground, including
duplicate answers for length-instantiated environments with fresh logic
variables as keys, and for non-length instantiated environments.</p>
<p>2-list/split-list representation (thank Darius Bacon for email) and
tradeoffs (ability to use <code>absento</code> on the “keys” list to do
lazy <code>not-in-envo</code>, making it non-recursive. Show issues that
remain: <code>lookupo</code> can still succeed an unbounded number of
times when the environment isn’t length instantiated.</p>
<p>Show association list constraints in clpset-faster-miniKanren (and
from the Beyond Cons paper) and its trade-offs, including duplicate
answers. (Is that an issue?) Include and acknowledge Michael
Ballantyne’s observation about the a-list constraints not being as
abstract as desirable, since ordering in the a-list still matters:
<code>((x . 5) (y . 6))</code> differs from
<code>((y . 6) (x . 5))</code>, even though they represent the same
environment. Future work!</p>
<h2 id="handling-mutation-using-store-passing-style">Handling mutation
using store-passing style</h2>
<p>write relational interpreters that handle mutation using
store-passing style</p>
<p>Issues with store passing/monadic style, forcing a “natural ordering”
for recursive calls. Can reordering of conjuncts based on the
ground-ness of terms help here when “running backwards”? Maybe, in this
sort of case, reordering of recursive calls is especially important.</p>
<p>What about delayed goals? What about Petr Lozov’s work?</p>
<p>Difficulty with failing fast.</p>
<p>Also, variable-to-value lookup now involves a second lookup. Perhaps
the alternative environment representation really helps here, as well,
with the store representation. combined environment/store
experiments.</p>
<p>using alist constraints?</p>
<p>Maybe we need both environment and store constraints to get decent
behavior.</p>
<p>Could recent work on constraint handling in miniKanren help here?</p>
<p>Lots of open research questions and opportunities.</p>
<p>Also, Nada Amin pointed out to me that you only need a store when you
have <code>set-car!</code> or whatever. You don’t need to use a store to
only support <code>set!</code> of variables. So, we can just use an
environment, and shadowing to update the environment, but still need to
thread the environment through monadically, I think. So it only helps
avoid the 2nd lookup—you still have to thread the environment through
monadically, I believe.</p>
<p>Can also implement an interpreter for a little imperative language
like IMP, which I’ve done before. Look at Polyconf 2015, for example.
I’ve also implemented Matt Might’s article on static analysis as a
relational interpreter, which involves mutation, if I recall
correctly.</p>
<h2 id="explicit-handling-of-errors">Explicit handling of errors</h2>
<p>write interpreters with explicit handling of errors, showing how
angelic execution can be used to synthesize expressions that, when
evaluated, generate a given error</p>
<p>Angelic execution example from Polyconf 2015—critique and improve
upon/riff upon that interpreter.</p>
<p>Tradeoffs and representing errors explicitly versus as failure (and
similarly for predicates in Scheme translated into miniKanren, whether
or not false is represented as failure and truth as success, versus
having an explicit Boolean as a second argument). Divergence and error,
shortcuts in the relational interpreter semantics to fail (to produce an
answer) versus possible divergence in Scheme. (I think I have another
chapter for discussing these encoding trade-offs.)</p>
<p>Synthesizing inputs that result in the given error.</p>
<p>Under which circumstances can we show that no such input exists? That
task is harder in miniKanren than in showing such an input does
exist.</p>
<p>Eigen, <code>absento</code>, abstracted value techniques.</p>
<p>Can we push this in metaKanren, or other miniKanren-in-miniKanren
implementations, synthesizing code that produces or doesn’t produce
errors? (Maybe can already do that. Seems like we should be able
to.)</p>
<h2 id="adding-enough-to-handle-append">Adding enough to handle
<code>append</code></h2>
<p>add <code>letrec</code> and recursive environments, and add a simple
pattern matcher to the relational Scheme interpreter, taking special
care to explicitly handle the cases of not matching (which is the
trickier part!), working up to a relational Scheme interpreter that can
interpret <code>append</code>, can synthesize arguments to
<code>append</code> using idioms like
<code>(append '(a b c) ',x)</code>, and can synthesize small code
expressions inside the definition of <code>append</code></p>
<p>Reynolds half-closure representation of recursive environments (may
be best to show first in Scheme)</p>
<p>(Maybe I should always include both the regular Scheme interpreter
along with miniKanren relational version. It’s more honest, easier to
understand, often can be used to check or debug the relational version.
and can be used to show concepts like divergence or error-versus-failure
and other encoding choices. Yes, I like this idea. I’m not afraid of
making the book longer.)</p>
<p>(Make sure conjunction of recursive calls for <code>cons</code> and
all that has been treated beforehand.)</p>
<p>(At some point need to show <code>define</code>, but maybe not
now.)</p>
<p>(Pattern matcher is tricky—probably worth its own chapter.)</p>
<p>Multiple argument application and <span
class="math inline"><em>λ</em></span> needs to be here, if not
before.</p>
<p>Primitives as first class, and non-empty initial environment, either
here or around here.</p>
<p><code>',x</code> versus <code>,x</code> behavior with
<code>run*</code>, <code>run 1</code>, <code>run 2</code>, showing the
expressions of relational Scheme interpreter, compared with
<code>appendo</code> in miniKanren directly.</p>
<p>Limits to synthesis due to divergence or inefficiency, especially due
to issues with conjunction of recursive calls and procedure
application.</p>
<p>Point to 2012 Scheme Workshop paper and ICFP 2017 pearl.</p>
<h2
id="comparison-between-append-in-scheme-appendo-in-minikanren-and-append-in-the-relational-scheme-interpreter-running-inside-minikanren">Comparison
between <code>append</code> in Scheme, <code>appendo</code> in
miniKanren, and <code>append</code> in the relational Scheme interpreter
running inside miniKanren</h2>
<p>discuss the similarities and differences between <code>append</code>
in Scheme, <code>appendo</code> in miniKanren, and <code>append</code>
in the relational Scheme interpreter running inside miniKanren</p>
<p>Where you can put logic variables, number of arguments, efficiency,
<code>',x</code> idiom versus <code>,x</code> in <code>append</code> in
Scheme-in-miniKanrin.</p>
<p>Create a figure/diagram showing the different layers of
interpretation.</p>
<p>Importance of ordering of conjuncts and other decisions in both
<code>appendo</code> and in the relational Scheme interpreter, including
for divergence behavior</p>
<p>list constraints, segment variables, segment unification, variadic,
Scheme <code>append</code> supporting variable number of arguments. Last
argument to<code>append</code> not needing to be a list or even a
pair.</p>
<h2
id="synthesis-of-a-term-showing-difference-between-lexical-scope-and-dynamic-scope">Synthesis
of a term showing difference between lexical scope and dynamic
scope</h2>
<p>explore a neat example from the 2017 ICFP pearl: synthesizing an
expression that evaluates to different values under lexical scope versus
dynamic scope through sharing a fresh variable in the expression
position for two relational interpreters, and using a disequality
constraint to enforce the the value arguments differ</p>
<p>Code for both interpreters: is there a nice way to abstract over the
difference?</p>
<pre><code>(run 1 (expr val1 val2)
  (=/= val1 val2)
  (eval-lexo expr val1)
  (eval-dyno expr val2))</code></pre>
<p>something like that.</p>
<p>Any sort of <code>absento</code> trick that can be used to generate
more interesting answers, like for twines?</p>
<p>Interesting idea/technique of sharing the same expression between
interpreters for the same language, but with different semantics. Seems
like we could push this further.</p>
<p>Similar example with call-by-value versus call-by-name or
call-by-need. Synthesize expressions showing difference in behavior.</p>
<h2 id="scheme-anti-interpreter">Scheme “anti”-interpreter</h2>
<p>write a relational Scheme “anti”-interpreter, <code>not-evalo</code>,
where <code>(not-evalo expr val)</code> succeeds when Scheme expression
<code>expr</code> does <em>not</em> evaluate to value
<code>val</code></p>
<p>Similar in spirit to the “doesn’t match” cases of the pattern matcher
in full-interp.</p>
<p>Need to make decisions about <em>how</em> the given expression
doesn’t evaluate to the given value: unbound variable, syntax error,
arity error, semantic error, divergence, etc.</p>
<p>Can do something equivalent with an anti-type inferencer version as
well.</p>
<p>Might assume expression parses and type checks, but doesn’t evaluate
to the given value.</p>
<p>How is not-evalo different from evalo along with a use of a
disequality constraint?</p>
<p>I don’t understand this very well.</p>
<p>Ongoing related experiments</p>
<h2 id="handling-call-by-name-and-call-by-need">Handling call-by-name
and call-by-need</h2>
<p>write relational Scheme interpreters that implement call-by-name and
call-by-need, rather than call-by-value</p>
<p>How do notions of call-by-name and call-by-need interact with trying
to avoid generate-and-test/premature grounding? Are these call-by’s
useful in this context?</p>
<p>How to implement call-by-need? In a functional way? In a relational
way? What is the connection, relationally, to memoization, Scheme’s
<code>force</code> and <code>delay</code>, tabling, etc.? How should
this be implemented in minikanren? What interesting synthesis examples
are possible?</p>
<h2 id="handling-scheme-memoized-functions">Handling Scheme memoized
functions</h2>
<p>write a relational Scheme interpreter that supports memoized
functions;</p>
<p>How does this interact with tabling?</p>
<p>Tabling built into miniKanren? Tabling implemented outside the
miniKanren implementation?</p>
<p>connections with abstract interpretation?</p>
<p>I’m not sure how to do this. Does memoing in Scheme require mutation,
or can it be done with a store, or whatever? A purely functional
implementation in Scheme would be helpful to start with.</p>
<p>Is this an issue of memoization and relationality?</p>
<p>What about Scheme-in-Scheme-in-miniKanren? Or
scheme-in-miniKanren-in-miniKanren? Any additional leverage we can
get?</p>
<h2 id="writing-a-relational-abstract-interpreter">Writing a relational
abstract interpreter</h2>
<p>write a relational abstract interpreter</p>
<p>various attempts with collaborators over the years are worth
revisiting</p>
<p>some of the current work on constraint extensions to miniKanren might
be helpful</p>
<p>miniKanren-in-miniKanren with aggregate operations</p>
<p>is tabling actually useful here?</p>
<p>Seems a bit like shallow-versus-deep versions of
miniKanren-in-miniKanren, with <code>run 1</code> versus
<code>run*</code>, or <code>run n</code> semantics</p>
<p>For some of these topics, I think just clearly expressing the
problems, apparent issues, et cetera, would already be very useful.
(Problem finding versus problem solving.)</p>
<p>Still, would be fun to write attempts at relational abstract
interpreters, and explore the issues and what seems to be lacking.</p>
<h2 id="delayed-goals">Delayed goals</h2>
<p>add delayed goals to faster-miniKanren, and explore uses of—and
tradeoffs of—delayed goals in relational interpreters</p>
<h2 id="speeding-up-the-interpreter">Speeding up the interpreter</h2>
<p>explore techniques for radically speeding up the interpreter in
certain cases, such as dynamic reordering of conjunctions of recursive
calls based on groundness of terms, and using a Scheme function rather
than a miniKanren relation for variable lookup in the interpreter’s
environment when the arguments are sufficiently ground, working up to a
relational Scheme interpreter that can synthesize <code>append</code>
from expression/value pairs</p>
<h2 id="synthesizing-append-using-associativity">Synthesizing
<code>append</code> using associativity</h2>
<p>explore synthesizing <code>append</code> and other recursive
definitions using properties such as <em>associativity</em>, rather than
only input/output pairs</p>
<h2
id="exploring-sophisticated-behavior-under-relational-interpretation-proof-checker-and-quasiquote-quine-generation">Exploring
sophisticated behavior under relational interpretation: proof checker
and quasiquote Quine generation</h2>
<p>explore sophisticated example programs from the 2017 ICFP pearl:
proof checker becomes theorem prover via relational interpretation, and
quasiquote Quine generation using a micro-Scheme in mini-Scheme in
miniKanren in Scheme</p>
<h2 id="build-your-own-barliman">Build Your Own Barliman</h2>
<p>build a simple clone of Barliman, including Barliman’s technique of
trying to parse an expression relationally in the hope of failing fast,
and throwing away any information gained upon success to avoid premature
grounding before calling the evaluator, and also running each
input/output pair on its own, in parallel with the entire synthesis
problem (once again, hoping to fail fast)</p>
<h2 id="wanted-a-relational-hygienic-macro-expander">Wanted: a
relational hygienic macro expander</h2>
<p>(as an aside from implementing relational interpeters) discuss lack
of a relational hygienic macro expander, its implications, possible work
arounds, and open problems</p>
<h2 id="relational-compiler-as-opposed-to-interpreter">Relational
compiler, as opposed to interpreter</h2>
<p>(Galois papers?)</p>
<p>(as an aside from implementing relational interpeters) discuss
relational compiler, rather than interpreter, for Scheme, along with
tradeoffs, opportunities, and problems</p>
<h2 id="staging-interpreters-using-staged-minikanren">Staging
interpreters using staged-miniKanren</h2>
<p>use the staged-miniKanren system to perform staged evaluation of
relational interpreters, giving cool examples from the PLDI paper and
repo</p>
<h2 id="free-and-bound-variables-using-setkanrenclpset">Free and bound
variables using setKanren/CLP(Set)</h2>
<p>consider the apparently simple notions of free and bound variables
from a relational context, implementing C311-style functions
relationally using setKanren/CLP(Set)</p>
<h2 id="adding-arithmetic-to-a-relational-scheme-interpreter">Adding
arithmetic to a relational Scheme interpreter</h2>
<p>consider the apparently simple task of adding arithmetic to a
relational Scheme interpreter, and explore the various ways this may be
done, including using variable projection, delayed goals, tagged Peano
numerals, “Kiselyov” numerals, finite domain constraints, and
CLP(SMT)</p>
<h2
id="a-small-step-lambda-calculus-reducer-and-capture-avoiding-substitution">A
small-step <span class="math inline"><em>λ</em></span>-calculus reducer
and capture-avoiding substitution</h2>
<p>write a small-step <span
class="math inline"><em>λ</em></span>-calculus reducer, based on
capture-avoiding substitution, exploring issues related to names and
binding</p>
<h2 id="a-small-step-lambda-calculus-reducer-using-de-bruijn-notation">A
small-step <span class="math inline"><em>λ</em></span>-calculus reducer,
using De Bruijn notation</h2>
<p>write a small-step <span
class="math inline"><em>λ</em></span>-calculus reducer, using De Bruijn
notation, and explore issues and tradeoffs</p>
<h2 id="a-small-step-term-reducer-for-the-ski-combinator-calculus">A
small-step term reducer for the SKI combinator calculus</h2>
<p>write a small-step term reducer for the SKI combinator calculus, and
explore the tradeoffs in terms of avoiding nominal issues with
capture-avoiding substitution and <span
class="math inline"><em>α</em></span>-equivalence, and the difficulties
related to failing fast, showing <span
class="math inline"><em>Ω</em></span> as a small-step Quine, working up
to synthesizing combinator terms and fixpoint combinators (Question: can
this reducer be staged by staged-miniKanren?)</p>
<h2
id="normalization-by-evaluation-relational-style">Normalization-by-evaluation,
relational style</h2>
<p>explore the technique of normalization-by-evaluation (or
<em>NBE</em>) from a relational standpoint, resulting in two relations,
<code>evalo</code> and <code>unevalo</code>, that together can
synthesize a fixpoint function in Scheme (and explore technique for
ensuring freshness of lexical variables using <code>absento</code> and a
list of variables encountered so far (which do not have to be
ground))</p>
<h2
id="microkanren-in-the-barliman-style-relational-scheme-interpreter">microKanren
in the Barliman-style relational Scheme interpreter</h2>
<p>run a slightly massaged version of the Scheme code for microKanren in
the Barliman-style relational Scheme interpreter, then explore the
behavior of microKanren programs in this relational context, including
the behavior of extra-logical operators such as <code>varo</code></p>
<h2
id="shallow-medium-and-deep-embeddings-of-minikanren-in-minikanren">Shallow,
medium, and deep embeddings of miniKanren-in-miniKanren</h2>
<p>implement shallow, medium, and deep embeddings of
miniKanren-in-miniKanren, and run queries that share arguments between
shallower and deeper embeddings to expore tradeoffs between performance
versus expressive power;</p>
<h2
id="relational-behavior-of-extra-logical-operators-in-a-deep-embedding-of-minikanren-in-minikanren">Relational
behavior of extra-logical operators in a deep embedding of miniKanren in
miniKanren</h2>
<p>explore the relational behavior of extra-logical operators in a deep
embedding of miniKanren in miniKanren, including aggregate operators
inspired by Prolog’s <code>findall</code> and <code>setof</code>
predicates, implemented using setKanren/CLP(Set)</p>
</body>
</html>
